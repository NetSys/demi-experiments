{
  "additional_metadata": null,
  "argv": [
    "./interposition/src/main/python/setup.py",
    "-t",
    "-n",
    "akka-raft-fuzz4"
  ],
  "cwd": "/Users/cs/Research/UCB/code/sts2-applications",
  "host": {
    "cpu_info": "",
    "free": "",
    "name": "yossarian",
    "num_cores": "0",
    "uptime": "16:26  up 4 days, 19:17, 6 users, load averages: 2.12 1.60 1.45"
  },
  "modules": {
    "sts2": {
      "branch": "raft-leader-safety",
      "commit": "3dfe86dbb7af633f06d46346be8c86664b2b7303",
      "diff": "diff --git a/interposition/src/main/scala/verification/RunnerUtils.scala b/interposition/src/main/scala/verification/RunnerUtils.scala\nindex 9956dec..a2dc0de 100644\n--- a/interposition/src/main/scala/verification/RunnerUtils.scala\n+++ b/interposition/src/main/scala/verification/RunnerUtils.scala\n@@ -3,6 +3,7 @@ package akka.dispatch.verification\n import scala.collection.mutable.Queue\n import scala.collection.mutable.SynchronizedQueue\n import scala.collection.mutable.HashSet\n+import scala.collection.mutable.HashMap\n \n import akka.actor.Props\n \n@@ -673,4 +674,64 @@ object RunnerUtils {\n       case _ =>\n     }\n   }\n+\n+  /**\n+   * Make it easier to construct specifically delivery orders manually.\n+   *\n+   * Given:\n+   *  - An event trace to be twiddled with\n+   *  - A sequence of UniqueMsgSends.ids (the id value from the UniqueMsgSends\n+   *     contained in event trace).\n+   *\n+   * Return: a new event trace that has UniqueMsgEvents and\n+   * UniqueTimerDeliveries arranged in the order\n+   * specified by the given sequences of ids\n+   */\n+  // TODO(cs): allow caller to specify locations of external events. For now\n+  // just put them all at the front.\n+  def reorderDeliveries(trace: EventTrace, ids: Seq[Int]): EventTrace = {\n+    val result = new SynchronizedQueue[Event]\n+\n+    val id2send = new HashMap[Int, UniqueMsgSend]\n+    trace.events.foreach {\n+      case u @ UniqueMsgSend(m, id) =>\n+        id2send(id) = u\n+      case _ =>\n+    }\n+\n+    val id2delivery = new HashMap[Int, Event]\n+    trace.events.foreach {\n+      case u @ UniqueMsgEvent(m, id) =>\n+        id2delivery(id) = u\n+      case u @ UniqueTimerDelivery(t, id) =>\n+        id2delivery(id) = u\n+      case _ =>\n+    }\n+\n+    // Put all SpawnEvents, external events at the beginning of the trace\n+    trace.events.foreach {\n+      case u @ UniqueMsgSend(m, id) =>\n+        if (EventTypes.isExternal(u)) {\n+          result += u\n+        }\n+      case u @ UniqueMsgEvent(m, id) =>\n+      case u @ UniqueTimerDelivery(t, id) =>\n+      case e => result += e\n+    }\n+\n+    // Now append all the specified deliveries\n+    ids.foreach {\n+      case id =>\n+        if (id2delivery contains id) {\n+          result += id2delivery(id)\n+        } else {\n+          // fabricate a UniqueMsgEvent\n+          val msgSend = id2send(id).m\n+          result += UniqueMsgEvent(MsgEvent(\n+            msgSend.sender, msgSend.receiver, msgSend.msg), id)\n+        }\n+    }\n+\n+    return new EventTrace(result, trace.original_externals)\n+  }\n }\ndiff --git a/src/main/scala/pl/project13/Runner.scala b/src/main/scala/pl/project13/Runner.scala\nindex a48e8b5..16f6390 100644\n--- a/src/main/scala/pl/project13/Runner.scala\n+++ b/src/main/scala/pl/project13/Runner.scala\n@@ -34,8 +34,11 @@ class RaftMessageFingerprinter extends MessageFingerprinter {\n     val str = msg match {\n       case RequestVote(term, ref, lastTerm, lastIdx) =>\n         ((\"RequestVote\", term, removeId(ref), lastTerm, lastIdx)).toString\n+        //((\"RequestVote\", removeId(ref))).toString\n       case LeaderIs(Some(ref), msg) =>\n         (\"LeaderIs\", removeId(ref)).toString\n+      //case VoteCandidate(term) =>\n+      //  (\"VoteCandidate\").toString\n       case m =>\n         \"\"\n     }\n@@ -118,18 +121,6 @@ object Init {\n     return newRef\n   }\n \n-  def eventMapper(e: Event) : Option[Event] = {\n-    e match {\n-      case MsgSend(snd,rcv,ChangeConfiguration(config)) =>\n-        // Regenerate the ChangeConfiguration message with new ActorRefs.\n-        val updatedRefs = config.members.map(Init.updateActorRef)\n-        val updatedConfig = ChangeConfiguration(ClusterConfiguration(updatedRefs))\n-        return Some(MsgSend(snd,rcv,updatedConfig))\n-      case m =>\n-        return Some(m)\n-    }\n-  }\n-\n   def externalMessageFilter(msg: Any) = {\n     msg match {\n       case ChangeConfiguration(_) => true\n@@ -151,14 +142,14 @@ object Main extends App {\n   fingerprintFactory.registerFingerprinter(new RaftMessageFingerprinter)\n \n   // -- Used for initial fuzzing: --\n-  val members = (1 to 9) map { i => s\"raft-member-$i\" }\n+  val members = (1 to 4) map { i => s\"raft-member-$i\" }\n   val prefix = Array[ExternalEvent]() ++\n     members.map(member =>\n       Start(Init.actorCtor, member)) ++\n     members.map(member =>\n-      Send(member, new BootstrapMessageConstructor(Set[Int]()))) // ++\n-  //  Array[ExternalEvent](WaitQuiescence()\n-  //)\n+      Send(member, new BootstrapMessageConstructor(Set[Int]())))\n+    Array[ExternalEvent](WaitQuiescence()\n+  )\n   // -- --\n \n   def shutdownCallback() = {\n@@ -180,12 +171,16 @@ object Main extends App {\n   val weights = new FuzzerWeights(kill=0.00, send=0.3, wait_quiescence=0.0,\n                                   partition=0.0, unpartition=0)\n   val messageGen = new ClientMessageGenerator(members)\n-  val fuzzer = new Fuzzer(500, weights, messageGen, prefix)\n+  val fuzzer = new Fuzzer(0, weights, messageGen, prefix)\n \n   val fuzz = true\n \n   var traceFound: EventTrace = null\n   var violationFound: ViolationFingerprint = null\n+  var depGraph : Graph[Unique, DiEdge] = null\n+  var initialTrace : Queue[Unique] = null\n+  var filteredTrace : Queue[Unique] = null\n+\n   if (fuzz) {\n     def replayerCtor() : ReplayScheduler = {\n       val replayer = new ReplayScheduler(schedulerConfig)\n@@ -194,24 +189,132 @@ object Main extends App {\n     val tuple = RunnerUtils.fuzz(fuzzer, raftChecks.invariant,\n                                  schedulerConfig,\n                                  validate_replay=Some(replayerCtor),\n-                                 maxMessages=Some(20000))\n+                                 maxMessages=Some(170)) // XXX\n     traceFound = tuple._1\n     violationFound = tuple._2\n+    depGraph = tuple._3\n+    initialTrace = tuple._4\n+    filteredTrace = tuple._5\n   }\n \n-  val (mcs, stats, verified_mcs, violation) =\n-  RunnerUtils.stsSchedDDMin(false,\n-    schedulerConfig,\n-    traceFound,\n-    violationFound,\n-    actorNameProps=Some(ExperimentSerializer.getActorNameProps(traceFound)))\n-\n-  val (_, intMinTrace) = RunnerUtils.minimizeInternals(schedulerConfig,\n-                        mcs,\n-                        verified_mcs.get,\n-                        ExperimentSerializer.getActorNameProps(traceFound),\n-                        violationFound)\n-\n-  RunnerUtils.printMinimizationStats(\n-    traceFound, None, verified_mcs.get, intMinTrace, schedulerConfig.messageFingerprinter)\n+  if (fuzz) {\n+    var provenanceTrace = traceFound.intersection(filteredTrace, fingerprintFactory)\n+\n+    val serializer = new ExperimentSerializer(\n+      fingerprintFactory,\n+      new RaftMessageSerializer)\n+\n+    val dir = serializer.record_experiment(\"akka-raft-fuzz4\",\n+      traceFound.filterCheckpointMessages(), violationFound,\n+      depGraph=Some(depGraph), initialTrace=Some(initialTrace),\n+      filteredTrace=Some(filteredTrace))\n+\n+    val (mcs, stats, verified_mcs, violation) =\n+    RunnerUtils.stsSchedDDMin(false,\n+      schedulerConfig,\n+      provenanceTrace,\n+      violationFound,\n+      actorNameProps=Some(ExperimentSerializer.getActorNameProps(traceFound)))\n+\n+    val mcs_dir = serializer.serializeMCS(dir, mcs, stats, verified_mcs, violation, false)\n+\n+    // Actually try minimizing twice, to make it easier to understand what's\n+    // going on during each \"Ignoring next\" run.\n+    val (intMinStats, intMinTrace) = RunnerUtils.minimizeInternals(schedulerConfig,\n+                          mcs,\n+                          verified_mcs.get,\n+                          ExperimentSerializer.getActorNameProps(traceFound),\n+                          violationFound)\n+\n+    RunnerUtils.printMinimizationStats(\n+      traceFound, Some(filteredTrace), verified_mcs.get, intMinTrace, schedulerConfig.messageFingerprinter)\n+\n+    // Second minimization\n+    val (intMinStats2, intMinTrace2) = RunnerUtils.minimizeInternals(schedulerConfig,\n+                          mcs,\n+                          intMinTrace,\n+                          ExperimentSerializer.getActorNameProps(traceFound),\n+                          violationFound)\n+\n+    RunnerUtils.printMinimizationStats(\n+      traceFound, Some(filteredTrace), verified_mcs.get, intMinTrace2, schedulerConfig.messageFingerprinter)\n+\n+    serializer.recordMinimizedInternals(mcs_dir, intMinStats2, intMinTrace2)\n+    println(\"MCS DIR: \" + mcs_dir)\n+  } else { // !fuzz\n+    val dir = \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz4_2015_07_30_18_00_35_DDMin_STSSchedNoPeek\"\n+\n+    val deserializer = new ExperimentDeserializer(dir)\n+    val msgDeserializer = new RaftMessageDeserializer(Instrumenter()._actorSystem)\n+    val replayTrace = RunnerUtils.replayExperiment(dir,\n+      schedulerConfig, msgDeserializer, traceFile=ExperimentSerializer.minimizedInternalTrace)\n+\n+    println(\"replayTrace:\")\n+    replayTrace.events.foreach {\n+      case e => println(e)\n+    }\n+\n+    val reordered = RunnerUtils.reorderDeliveries(replayTrace,\n+      Seq(\n+       // UniqueMsgEvent(MsgEvent(deadLetters,raft-member-4,ChangeConfiguration(StableRaftConfiguration(Set(raft-member-1,\n+       //   raft-member-2, raft-member-3,\n+       //   raft-member-4)))),3436)\n+       3436,\n+       // UniqueMsgEvent(MsgEvent(deadLetters,raft-member-1,ChangeConfiguration(StableRaftConfiguration(Set(raft-member-1,\n+       //   raft-member-2, raft-member-3, raft-member-4)))),3434)\n+       3434,\n+       // UniqueMsgEvent(MsgEvent(deadLetters,raft-member-4,Timer(election-timer,ElectionTimeout,false,1)),3437)\n+       3437,\n+       // UniqueMsgEvent(MsgEvent(deadLetters,raft-member-3,ChangeConfiguration(StableRaftConfiguration(Set(raft-member-1,\n+       // raft-member-2, raft-member-3, raft-member-4)))),3435)\n+       3435,\n+       // UniqueMsgEvent(MsgEvent(deadLetters,raft-member-3,Timer(election-timer,ElectionTimeout,false,1)),3442)\n+       3442,\n+       // UniqueMsgEvent(MsgEvent(raft-member-3,raft-member-3,BeginElection),3443)\n+       3443,\n+       // UniqueMsgEvent(MsgEvent(raft-member-3,raft-member-1,RequestVote(Term(1),\n+       //   Actor[akka://new-system-3/user/raft-member-3#669221861],Term(0),0)),3446)\n+       3446,\n+       // UniqueMsgSend(MsgSend(raft-member-4,raft-member-4,BeginElection),3439)\n+       3439\n+        ))\n+\n+    // Should have next:\n+    // UniqueMsgEvent(MsgEvent(raft-member-4,raft-member-3,RequestVote(Term(2),Actor[akka://new-system-0/user/raft-member-4#-1415506837],Term(0),0)),3457)\n+    // UniqueMsgEvent(MsgEvent(raft-member-1,raft-member-3,VoteCandidate(Term(0))),3449)\n+    // UniqueMsgEvent(MsgEvent(raft-member-3,raft-member-4,VoteCandidate(Term(2))),3458)\n+    // UniqueMsgEvent(MsgEvent(raft-member-1,raft-member-3,VoteCandidate(Term(2))),3466)\n+\n+    val reorderedReplay = RunnerUtils.replayExperiment(reordered,\n+      schedulerConfig, deserializer.get_actors, None)\n+\n+    println(\"Resulting Replay:\")\n+    reorderedReplay.events.foreach {\n+      case e => println(e)\n+    }\n+\n+    // Keep the same prefix of deliveries\n+    var ids = Seq() ++ reorderedReplay.events.flatMap {\n+      case UniqueMsgEvent(m,id) => Some(id)\n+      case UniqueTimerDelivery(t,id) => Some(id)\n+      case _ => None\n+    } ++ Seq(\n+      // UniqueMsgSend(MsgSend(raft-member-4,raft-member-3,RequestVote(Term(1)\n+      //  ,Actor[akka://new-system-3/user/raft-member-4#7463611],Term(0),0)),3487)\n+      3487,\n+      //UniqueMsgSend(MsgSend(raft-member-1,raft-member-3,VoteCandidate(Term(0))),3484)\n+      3484\n+    )\n+\n+    val reordered2 = RunnerUtils.reorderDeliveries(reorderedReplay, ids)\n+\n+    val reorderedReplay2 = RunnerUtils.replayExperiment(reordered2,\n+      schedulerConfig, deserializer.get_actors, None)\n+\n+    println(\"Resulting Replay2:\")\n+    reorderedReplay2.events.foreach {\n+      case e => println(e)\n+    }\n+\n+  }\n }\ndiff --git a/src/main/scala/pl/project13/scala/akka/raft/Candidate.scala b/src/main/scala/pl/project13/scala/akka/raft/Candidate.scala\nindex 11bde8e..710cfa6 100644\n--- a/src/main/scala/pl/project13/scala/akka/raft/Candidate.scala\n+++ b/src/main/scala/pl/project13/scala/akka/raft/Candidate.scala\n@@ -28,8 +28,13 @@ private[raft] trait Candidate {\n         val request = RequestVote(m.currentTerm, m.clusterSelf, replicatedLog.lastTerm, replicatedLog.lastIndex)\n         m.membersExceptSelf foreach { _ ! request }\n \n-        val includingThisVote = m.incVote\n-        stay() using includingThisVote.withVoteFor(m.currentTerm, m.clusterSelf)\n+        if (!(m.votes contains m.currentTerm)) {\n+          val includingThisVote = m.incVote\n+          stay() using includingThisVote.withVoteFor(m.currentTerm, m.clusterSelf)\n+        } else {\n+          // We already voted for ourself this Term!\n+          stay()\n+        }\n       }\n \n     case Event(msg: RequestVote, m: ElectionMeta) if m.canVoteIn(msg.term) =>\ndiff --git a/src/main/scala/pl/project13/scala/akka/raft/RaftActor.scala b/src/main/scala/pl/project13/scala/akka/raft/RaftActor.scala\nindex 51676b8..76427b5 100644\n--- a/src/main/scala/pl/project13/scala/akka/raft/RaftActor.scala\n+++ b/src/main/scala/pl/project13/scala/akka/raft/RaftActor.scala\n@@ -50,7 +50,9 @@ abstract class RaftActor extends Actor with LoggingFSM[RaftState, Metadata]\n     case m =>\n       //println(\"RAFT \" + self.path.name + \" FSM received \" + m + \" \" + super.getLog.map(_.stateName) + \" \" +\n       //  isTimerActive(ElectionTimeoutTimerName) )\n+      println(\"BEFORE RECEIVE: \" + stateData)\n       super.receive(m)\n+      println(\"AFTER RECEIVE: \" + stateData)\n       //println(\"RAFT \" + self.path.name + \" Done FSM received \" + m + \" \" + super.getLog.map(_.stateName))\n   }",
      "status": "On branch raft-leader-safety\nYour branch is up-to-date with 'origin/raft-leader-safety'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   interposition/src/main/scala/verification/RunnerUtils.scala\n\tmodified:   src/main/scala/pl/project13/Runner.scala\n\tmodified:   src/main/scala/pl/project13/scala/akka/raft/Candidate.scala\n\tmodified:   src/main/scala/pl/project13/scala/akka/raft/RaftActor.scala\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "",
    "uname": "Darwin yossarian 14.4.0 Darwin Kernel Version 14.4.0: Thu May 28 11:35:04 PDT 2015; root:xnu-2782.30.5~1/RELEASE_X86_64 x86_64"
  },
  "timestamp": "2015_08_01_16_26_01",
  "user": "cs"
}
