{
  "additional_metadata": null,
  "argv": [
    "./interposition/src/main/python/setup.py",
    "-t",
    "-n",
    "akka-raft-fuzz-long"
  ],
  "cwd": "/Users/cs/Research/UCB/code/sts2-applications",
  "host": {
    "cpu_info": "",
    "free": "",
    "name": "yossarian",
    "num_cores": "0",
    "uptime": "13:40  up 3 days, 11:37, 8 users, load averages: 2.61 1.92 1.82"
  },
  "modules": {
    "sts2": {
      "branch": "raft-56",
      "commit": "30b1bb9d508cc478a127236827c7ec4ad65cadbe",
      "diff": "diff --git a/src/main/scala/pl/project13/Runner.scala b/src/main/scala/pl/project13/Runner.scala\nindex 7128b72..1652627 100644\n--- a/src/main/scala/pl/project13/Runner.scala\n+++ b/src/main/scala/pl/project13/Runner.scala\n@@ -1,3 +1,5 @@\n+package akka.dispatch.verification\n+\n import akka.actor.{ Actor, ActorRef, DeadLetter }\n import akka.actor.{ActorSystem, ExtendedActorSystem}\n import akka.actor.Props\n@@ -16,6 +18,8 @@ import pl.project13.scala.akka.raft.model._\n import runner.raftchecks._\n import runner.raftserialization._\n import java.nio._\n+import akka.actor.FSM\n+import akka.actor.FSM.Timer\n \n import scalax.collection.mutable.Graph,\n        scalax.collection.GraphEdge.DiEdge,\n@@ -48,6 +52,32 @@ class RaftMessageFingerprinter extends MessageFingerprinter {\n     }\n     return None\n   }\n+\n+  // Does this message trigger a logical clock contained in subsequent\n+  // messages to be incremented?\n+  override def causesClockIncrement(msg: Any) : Boolean = {\n+    msg match {\n+      case Timer(\"election-timer\", _, _, _) => return true\n+      case _ => return false\n+    }\n+  }\n+\n+  // Extract a clock value from the contents of this message\n+  override def getLogicalClock(msg: Any) : Option[Long] = {\n+    msg match {\n+      case RequestVote(term, _, _, _) =>\n+        return Some(term.termNr)\n+      case AppendEntries(term, _, _, _, _) =>\n+        return Some(term.termNr)\n+      case VoteCandidate(term) =>\n+        return Some(term.termNr)\n+      case DeclineCandidate(term) =>\n+        return Some(term.termNr)\n+      case a: AppendResponse =>\n+        return Some(a.term.termNr)\n+      case _ => return None\n+    }\n+  }\n }\n \n class ClientMessageGenerator(raft_members: Seq[String]) extends MessageGenerator {\n@@ -173,7 +203,7 @@ object Main extends App {\n   val messageGen = new ClientMessageGenerator(members)\n   val fuzzer = new Fuzzer(0, weights, messageGen, prefix)\n \n-  val fuzz = false\n+  val fuzz = true\n \n   var traceFound: EventTrace = null\n   var violationFound: ViolationFingerprint = null\n@@ -186,11 +216,15 @@ object Main extends App {\n       val replayer = new ReplayScheduler(schedulerConfig)\n       return replayer\n     }\n+    def randomizationStrategy() : RandomizationStrategy = {\n+      return new SrcDstFIFO\n+    }\n     val tuple = RunnerUtils.fuzz(fuzzer, raftChecks.invariant,\n                                  schedulerConfig,\n                                  validate_replay=Some(replayerCtor),\n-                                 maxMessages=Some(500),\n-                                 invariant_check_interval=10) // XXX\n+                                 maxMessages=Some(3000),\n+                                 invariant_check_interval=30,  // XXX\n+                                 randomizationStrategyCtor=randomizationStrategy)\n     traceFound = tuple._1\n     violationFound = tuple._2\n     depGraph = tuple._3\n@@ -218,29 +252,60 @@ object Main extends App {\n       actorNameProps=Some(ExperimentSerializer.getActorNameProps(traceFound)))\n \n     val mcs_dir = serializer.serializeMCS(dir, mcs, stats, verified_mcs, violation, false)\n-\n-    // Actually try minimizing twice, to make it easier to understand what's\n-    // going on during each \"Ignoring next\" run.\n-    val (intMinStats, intMinTrace) = RunnerUtils.minimizeInternals(schedulerConfig,\n-                          mcs,\n-                          verified_mcs.get,\n-                          ExperimentSerializer.getActorNameProps(traceFound),\n-                          violationFound)\n-\n-    RunnerUtils.printMinimizationStats(\n-      traceFound, Some(filteredTrace), verified_mcs.get, intMinTrace, schedulerConfig.messageFingerprinter)\n-\n-    serializer.recordMinimizedInternals(mcs_dir, intMinStats, intMinTrace)\n     println(\"MCS DIR: \" + mcs_dir)\n   } else { // !fuzz\n     val dir =\n-    \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz-long_2015_08_04_22_50_11_DDMin_STSSchedNoPeek\"\n+    \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz-long_2015_08_27_12_49_03\"\n+    val mcs_dir =\n+    \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz-long_2015_08_27_12_49_03_DDMin_STSSchedNoPeek\"\n+\n+    val serializer = new ExperimentSerializer(\n+      fingerprintFactory,\n+      new RaftMessageSerializer)\n \n+    val deserializer = new ExperimentDeserializer(mcs_dir)\n     val msgDeserializer = new RaftMessageDeserializer(Instrumenter()._actorSystem)\n \n-    val replayTrace = RunnerUtils.replayExperiment(dir, schedulerConfig, msgDeserializer,\n-      traceFile=ExperimentSerializer.minimizedInternalTrace)\n+    val mcs = deserializer.get_mcs\n+    val actors = deserializer.get_actors\n+    val (verified_mcs, violationFound, _) = RunnerUtils.deserializeExperiment(mcs_dir, msgDeserializer)\n+\n+    var removalStrategy = new SrcDstFIFORemoval(verified_mcs,\n+      schedulerConfig.messageFingerprinter)\n+\n+    val (intMinStats, intMinTrace) = RunnerUtils.minimizeInternals(schedulerConfig,\n+      mcs, verified_mcs, actors, violationFound, removalStrategyCtor=() => removalStrategy)\n+\n+    serializer.recordMinimizationStats(mcs_dir, intMinStats,\n+            stats_file=ExperimentSerializer.internal_stats)\n+\n+    var additionalTraces = Seq[(String, EventTrace)]()\n \n-    RunnerUtils.printDeliveries(replayTrace)\n+    val minimizer = new FungibleClockMinimizer(schedulerConfig, mcs,\n+      intMinTrace, actors, violationFound,\n+      testScheduler=TestScheduler.DPORwHeuristics)\n+    val (wildcard_stats, clusterMinTrace) = minimizer.minimize\n+\n+    serializer.recordMinimizationStats(mcs_dir, wildcard_stats,\n+            stats_file=ExperimentSerializer.wildcard_stats)\n+\n+    additionalTraces = additionalTraces :+ ((\"FungibleClocks\", clusterMinTrace))\n+\n+    removalStrategy = new SrcDstFIFORemoval(clusterMinTrace,\n+      schedulerConfig.messageFingerprinter)\n+\n+    val (_, minTrace2) = RunnerUtils.minimizeInternals(schedulerConfig,\n+      mcs, clusterMinTrace, actors, violationFound,\n+      removalStrategyCtor=() => removalStrategy)\n+\n+    additionalTraces = additionalTraces :+ ((\"2nd intMin\", minTrace2))\n+\n+    val (traceFound, _, _) = RunnerUtils.deserializeExperiment(dir, msgDeserializer)\n+    val origDeserializer = new ExperimentDeserializer(dir)\n+    val filteredTrace = origDeserializer.get_filtered_initial_trace\n+\n+    RunnerUtils.printMinimizationStats(\n+      traceFound, filteredTrace, verified_mcs, intMinTrace, schedulerConfig.messageFingerprinter,\n+      additionalTraces)\n   }\n }",
      "status": "On branch raft-56\nYour branch is up-to-date with 'origin/raft-56'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   src/main/scala/pl/project13/Runner.scala\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\ttools/overwrite_uninteresting_fuzz_runs.rb\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "",
    "uname": "Darwin yossarian 14.5.0 Darwin Kernel Version 14.5.0: Wed Jul 29 02:26:53 PDT 2015; root:xnu-2782.40.9~1/RELEASE_X86_64 x86_64"
  },
  "timestamp": "2015_08_27_13_40_59",
  "user": "cs"
}
