{
  "additional_metadata": null,
  "argv": [
    "./interposition/src/main/python/setup.py",
    "-n",
    "akka-raft-fuzz_2015_05_17_17_14_33_DDMin_STSSchedNoPeek_shrunk"
  ],
  "cwd": "/Users/cs/Research/UCB/code/sts2-applications",
  "host": {
    "cpu_info": "",
    "free": "",
    "name": "yossarian",
    "num_cores": "0",
    "uptime": "17:14  up 5 days,  4:08, 5 users, load averages: 1.58 1.57 1.57"
  },
  "modules": {
    "sts2": {
      "branch": "akka-raft",
      "commit": "867ac7c957ca6f7f0433d9fcc06e5c71b82d70b0",
      "diff": "diff --git a/interposition/src/main/scala/verification/RunnerUtils.scala b/interposition/src/main/scala/verification/RunnerUtils.scala\nindex 7008185..1a8b563 100644\n--- a/interposition/src/main/scala/verification/RunnerUtils.scala\n+++ b/interposition/src/main/scala/verification/RunnerUtils.scala\n@@ -194,11 +194,29 @@ object RunnerUtils {\n                     allowPeek: Boolean,\n                     invariant: TestOracle.Invariant) :\n         Tuple4[Seq[ExternalEvent], MinimizationStats, Option[EventTrace], ViolationFingerprint] = {\n-    val sched = new STSScheduler(new EventTrace, allowPeek,\n-        fingerprintFactory, false)\n+    val sched = new STSScheduler(new EventTrace, allowPeek, fingerprintFactory, false)\n     sched.setInvariant(invariant)\n     val (trace, violation, _) = RunnerUtils.deserializeExperiment(experiment_dir, messageDeserializer, sched)\n     sched.original_trace = trace\n+    stsSchedDDMin(allowPeek, fingerprintFactory, trace, invariant, violation,\n+                  _sched=Some(sched))\n+  }\n+\n+  def stsSchedDDMin(allowPeek: Boolean,\n+                    fingerprintFactory: FingerprintFactory,\n+                    trace: EventTrace,\n+                    invariant: TestOracle.Invariant,\n+                    violation: ViolationFingerprint,\n+                    actorNameProps: Option[Seq[Tuple2[Props, String]]]=None,\n+                    _sched:Option[STSScheduler]=None) :\n+        Tuple4[Seq[ExternalEvent], MinimizationStats, Option[EventTrace], ViolationFingerprint] = {\n+    val sched = if (_sched != None) _sched.get else\n+                new STSScheduler(trace, allowPeek, fingerprintFactory, false)\n+    Instrumenter().scheduler = sched\n+    if (actorNameProps != None) {\n+      sched.setActorNamePropPairs(actorNameProps.get)\n+    }\n+    sched.setInvariant(invariant)\n \n     val ddmin = new DDMin(sched)\n     // STSSched doesn't actually pay any attention to WaitQuiescence, so just\n@@ -513,7 +531,7 @@ object RunnerUtils {\n \n     val shrinkable_sends = mcs flatMap {\n       case s @ Send(dst, ctor) =>\n-        if (!ctor.getComponents.isEmpty) {\n+        if (!ctor.getComponents.isEmpty ) {\n           Some(s)\n         } else {\n           None\n@@ -527,7 +545,10 @@ object RunnerUtils {\n     }\n \n     var components = shrinkable_sends.head.messageCtor.getComponents\n-    assert(shrinkable_sends.forall(s => s.messageCtor.getComponents == components))\n+    if (shrinkable_sends.forall(s => s.messageCtor.getComponents == components)) {\n+      println(\"shrinkable_sends: \" + shrinkable_sends)\n+      throw new IllegalArgumentException(\"Not all shrinkable_sends the same\")\n+    }\n \n     def modifyMCS(mcs: Seq[ExternalEvent], maskedIndices: Set[Int]): Seq[ExternalEvent] = {\n       return (mcs map {\ndiff --git a/interposition/src/main/scala/verification/Serializtion.scala b/interposition/src/main/scala/verification/Serializtion.scala\nindex 5454c37..3ff7a72 100644\n--- a/interposition/src/main/scala/verification/Serializtion.scala\n+++ b/interposition/src/main/scala/verification/Serializtion.scala\n@@ -201,12 +201,17 @@ class ExperimentSerializer(message_fingerprinter: FingerprintFactory, message_se\n     }\n   }\n \n+  // shrunk: whether the external events have been shrunk\n+  // (RunnerUtils.shrinkSendContents)\n+  // Return: the MCS dir\n   def serializeMCS(old_experiment_dir: String, mcs: Seq[ExternalEvent],\n                    stats: MinimizationStats,\n                    mcs_execution: Option[EventTrace],\n-                   violation: ViolationFingerprint) {\n+                   violation: ViolationFingerprint,\n+                   shrunk: Boolean) : String = {\n+    val shrunk_str = if (shrunk) \"_shrunk\" else \"\"\n     val new_experiment_dir = old_experiment_dir + \"_\" +\n-        stats.minimization_strategy + \"_\" + stats.test_oracle\n+        stats.minimization_strategy + \"_\" + stats.test_oracle + shrunk_str\n     ExperimentSerializer.create_experiment_dir(new_experiment_dir, add_timestamp=false)\n \n     val mcsBuf = JavaSerialization.serialize(mcs.toArray)\n@@ -226,7 +231,10 @@ class ExperimentSerializer(message_fingerprinter: FingerprintFactory, message_se\n \n     // Overwrite actors.bin, to make sure we include all actors, not just\n     // those left in the MCS.\n+    // TODO(cs): figure out how to do this properly in scala\n     (\"cp \" + old_experiment_dir + ExperimentSerializer.actors + \" \" + new_experiment_dir).!\n+\n+    return new_experiment_dir\n   }\n \n   def recordMinimizedInternals(output_dir: String,\ndiff --git a/notes.txt b/notes.txt\nindex 74317b3..c3512be 100644\n--- a/notes.txt\n+++ b/notes.txt\n@@ -1,3 +1,5 @@\n+TODO(cs): should have a tool for automatically generating the results table!\n+(where minimization gains come from)\n TODO(cs): should always be UniqueMsgEvents, not MsgEvents in trace.events.\n Assert that!\n \ndiff --git a/src/main/scala/pl/project13/Runner.scala b/src/main/scala/pl/project13/Runner.scala\nindex 19b3af4..d11aded 100644\n--- a/src/main/scala/pl/project13/Runner.scala\n+++ b/src/main/scala/pl/project13/Runner.scala\n@@ -223,41 +223,46 @@ object Main extends App {\n   serializer.serializeMCS(dir, mcs4, stats4, mcs_execution4, violation4)\n   */\n \n+  traceFound = traceFound.intersection(filteredTrace, fingerprintFactory)\n+\n   if (fuzz) {\n \n-    val shrinked_externals = RunnerUtils.shrinkSendContents(fingerprintFactory,\n-                                   traceFound.original_externals,\n-                                   traceFound,\n-                                   ExperimentSerializer.getActorNameProps(traceFound),\n-                                   raftChecks.invariant,\n-                                   violationFound)\n-\n-    var (mcs5, stats5, mcs_execution5, violation5) =\n-      RunnerUtils.stsSchedDDMin(dir,\n-        fingerprintFactory,\n-        new RaftMessageDeserializer(Instrumenter().actorSystem),\n-        false,\n-        raftChecks.invariant)\n-\n-    serializer.serializeMCS(dir, mcs5, stats5, mcs_execution5, violation5)\n-\n-    mcs_execution5 match {\n-      case Some(trace) =>\n-        // TODO(cs): do a better job of decoupling deserialization and experiment runner functions\n-        // in RunnerUtils. Have compose functions, that do both.\n-        val deserializer = new ExperimentDeserializer(dir)\n-\n-        var (stats, lastFailingTrace) =\n-          RunnerUtils.minimizeInternals(fingerprintFactory,\n-                                        mcs5,\n-                                        trace,\n-                                        deserializer.get_actors,\n-                                        raftChecks.invariant,\n-                                        violation5)\n-\n-        serializer.recordMinimizedInternals(dir, stats, lastFailingTrace)\n-      case None =>\n-        None\n+    for (shrink <- Seq(false, true)) {\n+      if (shrink) {\n+        traceFound.setOriginalExternalEvents(\n+          RunnerUtils.shrinkSendContents(\n+            fingerprintFactory,\n+            traceFound.original_externals,\n+            traceFound,\n+            ExperimentSerializer.getActorNameProps(traceFound),\n+            raftChecks.invariant,\n+            violationFound))\n+      }\n+\n+      var (mcs5, stats5, mcs_execution5, violation5) =\n+        RunnerUtils.stsSchedDDMin(false,\n+          fingerprintFactory,\n+          traceFound,\n+          raftChecks.invariant,\n+          violationFound,\n+          actorNameProps=Some(ExperimentSerializer.getActorNameProps(traceFound)))\n+\n+      val mcs_dir = serializer.serializeMCS(dir, mcs5, stats5, mcs_execution5, violation5, shrink)\n+\n+      mcs_execution5 match {\n+        case Some(trace) =>\n+          var (stats, lastFailingTrace) =\n+            RunnerUtils.minimizeInternals(fingerprintFactory,\n+                                          mcs5,\n+                                          trace,\n+                                          ExperimentSerializer.getActorNameProps(traceFound),\n+                                          raftChecks.invariant,\n+                                          violation5)\n+\n+          serializer.recordMinimizedInternals(mcs_dir, stats, lastFailingTrace)\n+        case None =>\n+          None\n+      }\n     }\n   }\n \n@@ -271,18 +276,19 @@ object Main extends App {\n \n     msgDeserializer = new RaftMessageDeserializer(Instrumenter().actorSystem)\n     val dummySched = new ReplayScheduler()\n-    val (mcs, trace, violation, actors) = RunnerUtils.deserializeMCS(mcs_dir,\n-                                                                     msgDeserializer,\n-                                                                     dummySched)\n-    dummySched.shutdown\n-    var (stats, lastFailingTrace) =\n-      RunnerUtils.minimizeInternals(fingerprintFactory,\n-                                    mcs,\n-                                    trace,\n-                                    actors,\n-                                    raftChecks.invariant,\n-                                    violation)\n-\n-    serializer.recordMinimizedInternals(mcs_dir, stats, lastFailingTrace)\n+    // val (mcs, trace, violation, actors) = RunnerUtils.deserializeMCS(mcs_dir,\n+    //                                                                  msgDeserializer,\n+\n+    // dummySched.shutdown\n+\n+    // var (stats, lastFailingTrace) =\n+    //   RunnerUtils.minimizeInternals(fingerprintFactory,\n+    //                                 mcs,\n+    //                                 trace,\n+    //                                 actors,\n+    //                                 raftChecks.invariant,\n+    //                                 violation)\n+\n+    // serializer.recordMinimizedInternals(mcs_dir, stats, lastFailingTrace)\n   }\n }",
      "status": "On branch akka-raft\nYour branch is up-to-date with 'origin/akka-raft'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   interposition/src/main/scala/verification/RunnerUtils.scala\n\tmodified:   interposition/src/main/scala/verification/Serializtion.scala\n\tmodified:   notes.txt\n\tmodified:   src/main/scala/pl/project13/Runner.scala\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "",
    "uname": "Darwin yossarian 14.3.0 Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64 x86_64"
  },
  "timestamp": "2015_05_17_17_14_36",
  "user": "cs"
}
