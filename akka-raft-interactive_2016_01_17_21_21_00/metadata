{
  "additional_metadata": null,
  "argv": [
    "././interposition/src/main/python/setup.py",
    "-t",
    "-n",
    "akka-raft-interactive"
  ],
  "cwd": "/Users/cs/Research/UCB/code/demi-applications",
  "host": {
    "cpu_info": "",
    "free": "",
    "name": "yossarian",
    "num_cores": "0",
    "uptime": "21:21  up 13 days, 10:21, 6 users, load averages: 1.78 1.83 1.83"
  },
  "modules": {
    "sts2": {
      "branch": "raft-42",
      "commit": "6e07b010d5631ed66588a4604aca95a3cdb65588",
      "diff": "diff --git a/src/main/scala/pl/project13/Runner.scala b/src/main/scala/pl/project13/Runner.scala\nindex 0acf921..67c90b0 100644\n--- a/src/main/scala/pl/project13/Runner.scala\n+++ b/src/main/scala/pl/project13/Runner.scala\n@@ -155,7 +155,7 @@ object Init {\n }\n \n object Main extends App {\n-  Instrumenter().setLogLevel(\"ERROR\")\n+  Instrumenter().setLogLevel(\"DEBUG\")\n   EventTypes.setExternalMessageFilter(Init.externalMessageFilter)\n   Instrumenter().setPassthrough\n   Instrumenter().actorSystem\n@@ -313,16 +313,48 @@ object Main extends App {\n     val mcs_dir =\n     \"experiments/akka-raft-fuzz-long_2015_08_30_21_57_21_DDMin_STSSchedNoPeek\"\n \n+    // val msgSerializer = new RaftMessageSerializer\n+    // val msgDeserializer = new RaftMessageDeserializer(Instrumenter()._actorSystem)\n+\n+    // def shouldRerunDDMin(externals: Seq[ExternalEvent]) =\n+    //   externals.exists({\n+    //     case s: Send => s.messageCtor.isInstanceOf[AppendWordConstuctor]\n+    //     case _ => false\n+    //   })\n+\n+    // RunnerUtils.runTheGamut(dir, mcs_dir, schedulerConfig, msgSerializer,\n+    //   msgDeserializer, shouldRerunDDMin=shouldRerunDDMin)\n+\n+    // --\n+\n     val msgSerializer = new RaftMessageSerializer\n     val msgDeserializer = new RaftMessageDeserializer(Instrumenter()._actorSystem)\n \n-    def shouldRerunDDMin(externals: Seq[ExternalEvent]) =\n-      externals.exists({\n-        case s: Send => s.messageCtor.isInstanceOf[AppendWordConstuctor]\n-        case _ => false\n-      })\n+    //RunnerUtils.replayExperiment(mcs_dir, schedulerConfig, msgDeserializer, traceFile=ExperimentSerializer.minimizedInternalTrace, externalsFile=ExperimentSerializer.mcs)\n+    RunnerUtils.replayExperiment(mcs_dir, schedulerConfig, msgDeserializer)\n+\n+    val deserializer = new ExperimentDeserializer(mcs_dir)\n+    val violation = deserializer.get_violation(msgDeserializer)\n+    val externals = deserializer.get_mcs\n+\n+    println(\"externals:\")\n+    externals.foreach { case e => println(e) }\n+\n+    // TODO(cs): put me in RunnerUtils, along with recording.\n+    val sched = new InteractiveScheduler(schedulerConfig)\n+    Instrumenter().scheduler = sched\n+    val (trace, maybeViolation) = sched.run(externals)\n+\n+    val serializer = new ExperimentSerializer(\n+      fingerprintFactory,\n+      msgSerializer)\n+\n+    val new_dir = serializer.record_experiment(\"akka-raft-interactive\",\n+      trace.filterCheckpointMessages())\n+\n+    //serializer.recordMinimizationStats(dir, stats)\n \n-    RunnerUtils.runTheGamut(dir, mcs_dir, schedulerConfig, msgSerializer,\n-      msgDeserializer, shouldRerunDDMin=shouldRerunDDMin)\n+    println(\"Found failing trace: \" + trace.filterCheckpointMessages().size)\n+    println(\"Saved trace at \" + new_dir)\n   }\n }\ndiff --git a/src/main/scala/pl/project13/scala/akka/raft/example/WordConcatRaftActor.scala b/src/main/scala/pl/project13/scala/akka/raft/example/WordConcatRaftActor.scala\nindex 13aaac3..8f87270 100644\n--- a/src/main/scala/pl/project13/scala/akka/raft/example/WordConcatRaftActor.scala\n+++ b/src/main/scala/pl/project13/scala/akka/raft/example/WordConcatRaftActor.scala\n@@ -35,21 +35,30 @@ class WordConcatRaftActor extends RaftActor {\n       val state = List(replicatedLog, nextIndex, matchIndex, stateData, words)\n       context.actorFor(\"../\" + CheckpointSink.name) ! CheckpointReply(state)\n     case m =>\n-      //println(\"RAFT \" + self.path.name + \" FSM received \" + m + \" \" + super.getLog.map(_.stateName) + \" \" +\n+      println(\"RAFT \" + self.path.name + \" FSM received \" + sender().path.name +\n+        \" \" + m + \" \" + super.getLog.map(_.stateName)) // + \" \" +\n       //  isTimerActive(ElectionTimeoutTimerName) )\n-      //println(\"BEFORE RECEIVE, LOG: \" + replicatedLog)\n-      //println(\"BEFORE RECEIVE, STATE: \" + stateData)\n-      //println(\"BEFORE RECEIVE, words: \" + words)\n-      //println(\"BEFORE RECEIVE, nextIndex: \" + nextIndex)\n-      //println(\"BEFORE RECEIVE, matchIndex: \" + matchIndex)\n+      val b4len = replicatedLog.entries.length\n+      val b4commands = replicatedLog.entries.toSet\n+      println(\"BEFORE RECEIVE, LOG: \" + replicatedLog.entries.map(e =>\n+        e.command.asInstanceOf[AppendWord].word).mkString(\" \"))\n+      println(\"BEFORE RECEIVE, STATE: \" + stateData)\n+      println(\"BEFORE RECEIVE, words: \" + words)\n+      println(\"BEFORE RECEIVE, nextIndex: \" + nextIndex)\n+      println(\"BEFORE RECEIVE, matchIndex: \" + matchIndex)\n       super.receive(m)\n-      //println(\"AFTER RECEIVE, LOG: \" + replicatedLog)\n-      //println(\"AFTER RECEIVE, STATE: \" + stateData)\n-      //println(\"AFTER RECEIVE, words: \" + words)\n-      //println(\"AFTER RECEIVE, nextIndex: \" + nextIndex)\n-      //println(\"AFTER RECEIVE, matchIndex: \" + matchIndex)\n-      //println(\"RAFT \" + self.path.name + \" Done FSM received \" + m + \" \" + super.getLog.map(_.stateName))\n+      println(\"AFTER RECEIVE, LOG: \" + replicatedLog.entries.map(e =>\n+        e.command.asInstanceOf[AppendWord].word).mkString(\" \"))\n+      println(\"AFTER RECEIVE, STATE: \" + stateData)\n+      println(\"AFTER RECEIVE, words: \" + words)\n+      println(\"AFTER RECEIVE, nextIndex: \" + nextIndex)\n+      println(\"AFTER RECEIVE, matchIndex: \" + matchIndex)\n+      println(\"RAFT \" + self.path.name + \" Done FSM received \" + m + \" \" + super.getLog.map(_.stateName))\n+      val aftercommands = replicatedLog.entries.toSet\n+      if (replicatedLog.entries.length < b4len ||\n+          aftercommands.intersect(b4commands).size != b4commands.size) {\n+        println(\"RAFT \" + self.path.name + \" =====----- \")\n+      }\n   }\n-\n }\n \ndiff --git a/src/main/scala/pl/project13/scala/akka/raft/model/LogIndexMap.scala b/src/main/scala/pl/project13/scala/akka/raft/model/LogIndexMap.scala\nindex 6a66005..9cf7471 100644\n--- a/src/main/scala/pl/project13/scala/akka/raft/model/LogIndexMap.scala\n+++ b/src/main/scala/pl/project13/scala/akka/raft/model/LogIndexMap.scala\n@@ -65,6 +65,20 @@ case class LogIndexMap private (private var backing: Map[ActorRef, Int], private\n       else math.min(oldQuorum, newQuorum)\n   }\n \n+  def i() : Int = {\n+    val indexCountPairs = backing\n+      .groupBy(_._2)\n+      .map { case (k, m) => k -> m.size }\n+      .toList\n+\n+    indexCountPairs match {\n+      case Nil => 0\n+      case _ =>\n+        indexCountPairs.sortBy(- _._2).head // sort by size\n+        ._1\n+    }\n+  }\n+\n   private def indexOnMajority(include: Set[ActorRef]): Int = {\n     val indexCountPairs = backing\n       .filterKeys(include)",
      "status": "On branch raft-42\nYour branch is ahead of 'origin/raft-42' by 7 commits.\n  (use \"git push\" to publish your local commits)\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   src/main/scala/pl/project13/Runner.scala\n\tmodified:   src/main/scala/pl/project13/scala/akka/raft/example/WordConcatRaftActor.scala\n\tmodified:   src/main/scala/pl/project13/scala/akka/raft/model/LogIndexMap.scala\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tlogs.txt\n\tlong.txt\n\tminimized.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "",
    "uname": "Darwin yossarian 14.5.0 Darwin Kernel Version 14.5.0: Tue Sep  1 21:23:09 PDT 2015; root:xnu-2782.50.1~1/RELEASE_X86_64 x86_64"
  },
  "timestamp": "2016_01_17_21_21_00",
  "user": "cs"
}
