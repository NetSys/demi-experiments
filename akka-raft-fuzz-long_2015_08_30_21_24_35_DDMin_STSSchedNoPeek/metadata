{
  "additional_metadata": null,
  "argv": [
    "./interposition/src/main/python/setup.py",
    "-n",
    "akka-raft-fuzz-long_2015_08_30_21_24_35_DDMin_STSSchedNoPeek"
  ],
  "cwd": "/Users/cs/Research/UCB/code/sts2-applications",
  "host": {
    "cpu_info": "",
    "free": "",
    "name": "yossarian",
    "num_cores": "0",
    "uptime": "21:24  up 6 days, 19:21, 9 users, load averages: 1.98 1.56 1.63"
  },
  "modules": {
    "sts2": {
      "branch": "raft-42",
      "commit": "a07b7e8a54fd62dfee13c1a610edd05bb023dd1d",
      "diff": "diff --git a/src/main/scala/pl/project13/Runner.scala b/src/main/scala/pl/project13/Runner.scala\nindex dfbe46c..56daa81 100644\n--- a/src/main/scala/pl/project13/Runner.scala\n+++ b/src/main/scala/pl/project13/Runner.scala\n@@ -52,6 +52,32 @@ class RaftMessageFingerprinter extends MessageFingerprinter {\n     }\n     return None\n   }\n+\n+  // Does this message trigger a logical clock contained in subsequent\n+  // messages to be incremented?\n+  override def causesClockIncrement(msg: Any) : Boolean = {\n+    msg match {\n+      case Timer(\"election-timer\", _, _, _) => return true\n+      case _ => return false\n+    }\n+  }\n+\n+  // Extract a clock value from the contents of this message\n+  override def getLogicalClock(msg: Any) : Option[Long] = {\n+    msg match {\n+      case RequestVote(term, _, _, _) =>\n+        return Some(term.termNr)\n+      case AppendEntries(term, _, _, _, _) =>\n+        return Some(term.termNr)\n+      case VoteCandidate(term) =>\n+        return Some(term.termNr)\n+      case DeclineCandidate(term) =>\n+        return Some(term.termNr)\n+      case a: AppendResponse =>\n+        return Some(a.term.termNr)\n+      case _ => return None\n+    }\n+  }\n }\n \n class AppendWordConstuctor(word: String) extends ExternalMessageConstructor {\n@@ -222,9 +248,9 @@ object Main extends App {\n   val weights = new FuzzerWeights(kill=0.00, send=0.3, wait_quiescence=0.0,\n                                   partition=0.0, unpartition=0)\n   val messageGen = new ClientMessageGenerator(members)\n-  val fuzzer = new Fuzzer(60, weights, messageGen, prefix, postfix=postfix)\n+  val fuzzer = new Fuzzer(200, weights, messageGen, prefix, postfix=postfix)\n \n-  val fuzz = false\n+  val fuzz = true\n \n   var traceFound: EventTrace = null\n   var violationFound: ViolationFingerprint = null\n@@ -239,7 +265,8 @@ object Main extends App {\n     }\n \n     def randomiziationCtor() : RandomizationStrategy = {\n-      return new FullyRandom(userDefinedFilter)\n+      //return new FullyRandom(userDefinedFilter)\n+      return new SrcDstFIFO(userDefinedFilter)\n     }\n     val tuple = RunnerUtils.fuzz(fuzzer, raftChecks.invariant,\n                                  schedulerConfig,\n@@ -267,7 +294,7 @@ object Main extends App {\n       depGraph=Some(depGraph), initialTrace=Some(initialTrace),\n       filteredTrace=Some(filteredTrace))\n \n-    val (mcs, stats, verified_mcs, violation) =\n+    val (mcs, stats1, verified_mcs, violation) =\n     RunnerUtils.stsSchedDDMin(false,\n       schedulerConfig,\n       traceFound,\n@@ -278,28 +305,137 @@ object Main extends App {\n       throw new RuntimeException(\"MCS wasn't validated\")\n     }\n \n-    val mcs_dir = serializer.serializeMCS(dir, mcs, stats, verified_mcs, violation, false)\n+    val mcs_dir = serializer.serializeMCS(dir, mcs, stats1, verified_mcs, violation, false)\n+    println(\"MCS DIR: \" + mcs_dir)\n+  } else { // !fuzz\n+    val dir =\n+    \"experiments/akka-raft-fuzz-long_2015_08_30_20_59_21\"\n+    val mcs_dir =\n+    \"experiments/akka-raft-fuzz-long_2015_08_30_20_59_21_DDMin_STSSchedNoPeek\"\n+\n+    val serializer = new ExperimentSerializer(\n+      fingerprintFactory,\n+      new RaftMessageSerializer)\n+\n+    val deserializer = new ExperimentDeserializer(mcs_dir)\n+    val msgDeserializer = new RaftMessageDeserializer(Instrumenter()._actorSystem)\n+\n+    // -- purely for printing stats --\n+    val (traceFound, _, _) = RunnerUtils.deserializeExperiment(dir, msgDeserializer)\n+    val origDeserializer = new ExperimentDeserializer(dir)\n+    val filteredTrace = origDeserializer.get_filtered_initial_trace\n+    // -- --\n+\n+    val (mcs, verified_mcs, violationFound, actors, stats) =\n+      RunnerUtils.deserializeMCS(mcs_dir, msgDeserializer)\n+\n+    var currentExternals = mcs\n+    var currentTrace = verified_mcs\n+    var currentStats = stats\n+\n+    var removalStrategy = new SrcDstFIFORemoval(currentTrace,\n+      schedulerConfig.messageFingerprinter)\n \n     val (intMinStats, intMinTrace) = RunnerUtils.minimizeInternals(schedulerConfig,\n-                          mcs,\n-                          verified_mcs.get,\n-                          ExperimentSerializer.getActorNameProps(traceFound),\n-                          violationFound)\n+      currentExternals, currentTrace, actors, violationFound,\n+      removalStrategyCtor=() => removalStrategy, stats=Some(currentStats))\n+\n+    currentTrace = intMinTrace\n+    currentStats = intMinStats\n+\n+    var additionalTraces = Seq[(String, EventTrace)]()\n+\n+    // fungibleClocks DDMin without backtracks.\n+    val (newMCS, clocksDDMinStats, clockDDMinTrace, _) =\n+      RunnerUtils.fungibleClocksDDMin(schedulerConfig,\n+        currentTrace,\n+        violationFound,\n+        actors,\n+        stats=Some(currentStats))\n+\n+    currentTrace = clockDDMinTrace.get\n+    currentStats = clocksDDMinStats\n+    currentExternals = newMCS\n+\n+    additionalTraces = additionalTraces :+ ((\"WildcardDDMinNoBacktracks\", clockDDMinTrace.get))\n+\n+    // Without backtracks first\n+    var minimizer = new FungibleClockMinimizer(schedulerConfig,\n+      currentExternals,\n+      currentTrace, actors, violationFound,\n+      //testScheduler=TestScheduler.DPORwHeuristics,\n+      stats=Some(currentStats))\n+    val (wildcard_stats1, clusterMinTrace1) = minimizer.minimize\n+\n+    currentTrace = clusterMinTrace1\n+    currentStats = wildcard_stats1\n+\n+    additionalTraces = additionalTraces :+ ((\"FungibleClocksNoBackTracks\", clusterMinTrace1))\n+\n+    // N.B. will be overwritten\n+    serializer.recordMinimizedInternals(mcs_dir,\n+       currentStats, currentTrace)\n \n     RunnerUtils.printMinimizationStats(\n-      traceFound, Some(filteredTrace), verified_mcs.get, intMinTrace, schedulerConfig.messageFingerprinter)\n+      traceFound, filteredTrace, verified_mcs, intMinTrace, schedulerConfig.messageFingerprinter,\n+      additionalTraces)\n \n-    serializer.recordMinimizedInternals(mcs_dir, intMinStats, intMinTrace)\n-    println(\"MCS DIR: \" + mcs_dir)\n-  } else { // !fuzz\n-    val dir =\n-    \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz-long_2015_08_12_14_26_44_DDMin_STSSchedNoPeek\"\n+    // Now with backtracks\n+    minimizer = new FungibleClockMinimizer(schedulerConfig, currentExternals,\n+      currentTrace, actors, violationFound,\n+      testScheduler=TestScheduler.DPORwHeuristics,\n+      stats=Some(currentStats))\n+    val (wildcard_stats2, clusterMinTrace2) = minimizer.minimize\n \n-    val msgDeserializer = new RaftMessageDeserializer(Instrumenter()._actorSystem)\n+    currentStats = wildcard_stats2\n+    currentTrace = clusterMinTrace2\n+\n+    additionalTraces = additionalTraces :+ ((\"FungibleClocks\", clusterMinTrace2))\n \n-    val replayTrace = RunnerUtils.replayExperiment(dir, schedulerConfig, msgDeserializer,\n-      traceFile=ExperimentSerializer.minimizedInternalTrace)\n+    removalStrategy = new SrcDstFIFORemoval(currentTrace,\n+      schedulerConfig.messageFingerprinter)\n \n-    RunnerUtils.printDeliveries(replayTrace)\n+     val (intMinStats2, minTrace2) = RunnerUtils.minimizeInternals(schedulerConfig,\n+       currentExternals, currentTrace, actors, violationFound,\n+       removalStrategyCtor=() => removalStrategy,\n+       stats=Some(currentStats))\n+\n+     currentStats = intMinStats2\n+     currentTrace = minTrace2\n+\n+     additionalTraces = additionalTraces :+ ((\"2nd intMin\", minTrace2))\n+\n+    // N.B. overwrite\n+    serializer.recordMinimizedInternals(mcs_dir,\n+       currentStats, currentTrace)\n+\n+    RunnerUtils.printMinimizationStats(\n+      traceFound, filteredTrace, verified_mcs, intMinTrace, schedulerConfig.messageFingerprinter,\n+      additionalTraces)\n+\n+    /*\n+    // fungibleClocks DDMin with backtracks.\n+    val (newMCS2, clocksDDMinStats2, clockDDMinTrace2, _) =\n+      RunnerUtils.fungibleClocksDDMin(schedulerConfig,\n+        clusterMinTrace2,\n+        violationFound,\n+        actors,\n+        testScheduler=TestScheduler.DPORwHeuristics,\n+        stats=Some(wildcard_stats2))\n+\n+    currentExternals= newMCS2\n+    currentStats = clocksDDMinStats2\n+    currentTrace = clockDDMinTrace2.get\n+\n+    // N.B. overwrite\n+    serializer.recordMinimizedInternals(mcs_dir,\n+       clocksDDMinStats2, clockDDMinTrace2.get)\n+\n+    additionalTraces = additionalTraces :+ ((\"WildcardDDMinNoBacktracks\", clockDDMinTrace2.get))\n+\n+    RunnerUtils.printMinimizationStats(\n+      traceFound, filteredTrace, verified_mcs, intMinTrace, schedulerConfig.messageFingerprinter,\n+      additionalTraces)\n+    */\n   }\n }",
      "status": "On branch raft-42\nYour branch is up-to-date with 'origin/raft-42'.\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   src/main/scala/pl/project13/Runner.scala\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\tsrc/main/scala/pl/project13/t\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "",
    "uname": "Darwin yossarian 14.5.0 Darwin Kernel Version 14.5.0: Wed Jul 29 02:26:53 PDT 2015; root:xnu-2782.40.9~1/RELEASE_X86_64 x86_64"
  },
  "timestamp": "2015_08_30_21_24_40",
  "user": "cs"
}
