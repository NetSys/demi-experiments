{
  "additional_metadata": null,
  "argv": [
    "./interposition/src/main/python/setup.py",
    "-n",
    "akka-raft-fuzz_2015_04_19_15_35_23_IncDDMin_DPOR"
  ],
  "cwd": "/Users/cs/Research/UCB/code/sts2-applications",
  "host": {
    "cpu_info": "",
    "free": "",
    "name": "yossarian",
    "num_cores": "0",
    "uptime": "15:37  up 2 days,  2:46, 5 users, load averages: 8.53 4.22 2.46"
  },
  "modules": {
    "sts2": {
      "branch": "akka-raft",
      "commit": "230d62a93f0f3913ae0f62260dbd784ec3e7fef0",
      "diff": "diff --git a/interposition/src/main/scala/verification/RunnerUtils.scala b/interposition/src/main/scala/verification/RunnerUtils.scala\nindex 65408f7..538f660 100644\n--- a/interposition/src/main/scala/verification/RunnerUtils.scala\n+++ b/interposition/src/main/scala/verification/RunnerUtils.scala\n@@ -1,6 +1,9 @@\n package akka.dispatch.verification\n \n import scala.collection.mutable.Queue\n+import scala.collection.mutable.HashSet\n+\n+import akka.actor.Props\n \n import scalax.collection.mutable.Graph,\n        scalax.collection.GraphEdge.DiEdge,\n@@ -10,6 +13,14 @@ import scalax.collection.mutable.Graph,\n // Utilities for writing Runner.scala files.\n object RunnerUtils {\n \n+  def countMsgEvents(trace: Iterable[Event]) : Int = {\n+    return trace.filter {\n+      case m: MsgEvent => true\n+      case t: TimerDelivery => true\n+      case _ => false\n+    } size\n+  }\n+\n   def fuzz(fuzzer: Fuzzer, invariant: TestOracle.Invariant,\n            fingerprintFactory: FingerprintFactory,\n            validate_replay:Option[() => ReplayScheduler]=None,\n@@ -75,9 +86,12 @@ object RunnerUtils {\n     // optimization...\n     println(\"Pruning events not in provenance of violation. This may take awhile...\")\n     val provenenceTracker = new ProvenanceTracker(initialTrace, depGraph)\n+    val origDeliveries = countMsgEvents(traceFound.filterCheckpointMessages.filterFailureDetectorMessages)\n     val filtered = provenenceTracker.pruneConcurrentEvents(violationFound)\n-    val numberFiltered = initialTrace.size - filtered.size\n-    println(\"Pruned \" + numberFiltered + \"/\" + initialTrace.size + \" concurrent events\")\n+    val numberFiltered = origDeliveries - countMsgEvents(filtered.map(u => u.event))\n+    // TODO(cs): track this number somewhere. Or reconstruct it from\n+    // initialTrace/filtered.\n+    println(\"Pruned \" + numberFiltered + \"/\" + origDeliveries + \" concurrent deliveries\")\n     return (traceFound, violationFound, depGraph, initialTrace, filtered)\n   }\n \n@@ -95,6 +109,20 @@ object RunnerUtils {\n     return (trace, violation, dep_graph)\n   }\n \n+  def deserializeMCS(experiment_dir: String,\n+      messageDeserializer: MessageDeserializer,\n+      scheduler: ExternalEventInjector[_] with Scheduler):\n+        Tuple4[Seq[ExternalEvent], EventTrace, ViolationFingerprint, Seq[Tuple2[Props, String]]] = {\n+    val deserializer = new ExperimentDeserializer(experiment_dir)\n+    Instrumenter().scheduler = scheduler\n+    scheduler.populateActorSystem(deserializer.get_actors)\n+    val violation = deserializer.get_violation(messageDeserializer)\n+    val trace = deserializer.get_events(messageDeserializer, Instrumenter().actorSystem)\n+    val mcs = deserializer.get_mcs\n+    val actorNameProps = deserializer.get_actors\n+    return (mcs, trace, violation, actorNameProps)\n+  }\n+\n   def replayExperiment(experiment_dir: String,\n                        fingerprintFactory: FingerprintFactory,\n                        messageDeserializer: MessageDeserializer,\n@@ -306,7 +334,9 @@ object RunnerUtils {\n         replayer.shutdown()\n         try {\n           replayer.populateActorSystem(actorsNameProps)\n-          verified_mcs = Some(replayer.replay(toReplay))\n+          val trace = replayer.replay(toReplay)\n+          trace.setOriginalExternalEvents(mcs)\n+          verified_mcs = Some(trace)\n           println(\"MCS Validated!\")\n         } catch {\n           case r: ReplayException =>\n@@ -317,4 +347,107 @@ object RunnerUtils {\n     }\n     return (mcs, ddmin.stats, verified_mcs, violation)\n   }\n+\n+  def minimizeInternals(fingerprintFactory: FingerprintFactory,\n+                        mcs: Seq[ExternalEvent],\n+                        verified_mcs: EventTrace,\n+                        actorNameProps: Seq[Tuple2[Props, String]],\n+                        invariant: TestOracle.Invariant,\n+                        violation: ViolationFingerprint,\n+                        event_mapper:Option[HistoricalScheduler.EventMapper]=None) :\n+      Tuple2[MinimizationStats, EventTrace] = {\n+\n+    // TODO(cs): factor this out to its own file, with nice interfaces.\n+    println(\"Minimizing internals..\")\n+    println(\"verified_mcs.original_externals: \" + verified_mcs.original_externals)\n+    val stats = new MinimizationStats(\"InternalMin\", \"STSSched\")\n+\n+    // TODO(cs): minor optimization: don't try to prune external messages.\n+    // MsgEvents we've tried ignoring so far. MultiSet to account for duplicate MsgEvent's\n+    val triedIgnoring = new MultiSet[(String, String, MessageFingerprint)]\n+\n+    // Filter out the next MsgEvent, and return the resulting EventTrace.\n+    // If we've tried filtering out all MsgEvents, return None.\n+    def getNextTrace(trace: EventTrace): Option[EventTrace] = {\n+      // Track what events we've kept so far in this iteration because we\n+      // already tried ignoring them previously. MultiSet to account for\n+      // duplicate MsgEvent's. TODO(cs): this may lead to some ambiguous cases.\n+      val keysThisIteration = new MultiSet[(String, String, MessageFingerprint)]\n+      // Whether we've found the event we're going to try ignoring next.\n+      var foundIgnoredEvent = false\n+\n+      // We accomplish two tasks as we iterate through trace:\n+      //   - Finding the next event we want to ignore\n+      //   - Filtering (keeping) everything that we don't want to ignore\n+      val modified = trace flatMap {\n+        case m @ MsgEvent(snd, rcv, msg) =>\n+          val key = (snd, rcv, fingerprintFactory.fingerprint(msg))\n+          keysThisIteration += key\n+          if (foundIgnoredEvent) {\n+            // We already chose our event to ignore. Keep all other events.\n+            Some(m)\n+          } else {\n+            // Check if we should ignore or keep this one.\n+            if (keysThisIteration.count(key) > triedIgnoring.count(key)) {\n+              // We found something to ignore\n+              println(\"Ignoring next: \" + key)\n+              foundIgnoredEvent = true\n+              triedIgnoring += key\n+              None\n+            } else {\n+              // Keep this one; we already tried ignoring it, but it was\n+              // not prunable.\n+              Some(m)\n+            }\n+          }\n+        case e =>\n+          Some(e)\n+      }\n+      if (foundIgnoredEvent) {\n+        return Some(new EventTrace(new Queue[Event] ++ modified,\n+                                   verified_mcs.original_externals))\n+      }\n+      // We didn't find anything else to ignore, so we're done\n+      return None\n+    }\n+\n+    val origTrace = verified_mcs.filterCheckpointMessages.filterFailureDetectorMessages\n+    var lastFailingTrace = origTrace\n+    // TODO(cs): make this more efficient? Currently O(n^2) overall.\n+    var nextTrace = getNextTrace(lastFailingTrace)\n+\n+    while (!nextTrace.isEmpty) {\n+      val sched = new STSScheduler(nextTrace.get, false, fingerprintFactory, false)\n+      sched.setActorNamePropPairs(actorNameProps)\n+      sched.setInvariant(invariant)\n+      event_mapper match {\n+        case Some(f) => sched.setEventMapper(f)\n+        case None => None\n+      }\n+      Instrumenter().scheduler = sched\n+      val prunedOpt = sched.test(mcs, violation, stats)\n+      prunedOpt match {\n+        case Some(trace) =>\n+          // Some other events may have been pruned by virtue of being absent. So\n+          // we reassign lastFailingTrace, then pick then next trace based on\n+          // it.\n+          val origSize = countMsgEvents(lastFailingTrace)\n+          val newSize = countMsgEvents(trace)\n+          val diff = origSize - newSize\n+          println(\"Ignoring worked! Pruned \" + diff + \"/\" + origSize + \" deliveries\")\n+          lastFailingTrace = trace\n+        case None =>\n+          // We didn't trigger the violation.\n+          println(\"Ignoring didn't work. Trying next\")\n+          None\n+      }\n+      nextTrace = getNextTrace(lastFailingTrace)\n+    }\n+    val origSize = countMsgEvents(origTrace)\n+    val newSize = countMsgEvents(lastFailingTrace.filterCheckpointMessages.filterFailureDetectorMessages)\n+    val diff = origSize - newSize\n+    println(\"Pruned \" + diff + \"/\" + origSize + \" deliveries in \" +\n+            stats.total_replays + \" replays\")\n+    return (stats, lastFailingTrace)\n+  }\n }\ndiff --git a/interposition/src/main/scala/verification/schedulers/STSScheduler.scala b/interposition/src/main/scala/verification/schedulers/STSScheduler.scala\nindex e466cf4..9c55ff3 100644\n--- a/interposition/src/main/scala/verification/schedulers/STSScheduler.scala\n+++ b/interposition/src/main/scala/verification/schedulers/STSScheduler.scala\n@@ -158,6 +158,7 @@ class STSScheduler(var original_trace: EventTrace,\n     var violationFound = false\n     violation match {\n       case Some(fingerprint) =>\n+        println(\"violationFound. Checking if matches\")\n         violationFound = fingerprint.matches(violationFingerprint)\n       case _ => None\n     }\n@@ -246,7 +247,12 @@ class STSScheduler(var original_trace: EventTrace,\n         //   event_orchestrator.trace.length + \" \" + event_orchestrator.current_event)\n         event_orchestrator.current_event match {\n           case SpawnEvent (_, _, name, _) =>\n-            event_orchestrator.trigger_start(name)\n+            if (event_orchestrator.actorToActorRef contains name) {\n+              println(\"Already started.. \" + name)\n+              event_orchestrator.unisolate_node(name)\n+            } else {\n+              event_orchestrator.trigger_start(name)\n+            }\n           case KillEvent (name) =>\n             event_orchestrator.trigger_kill(name)\n           case PartitionEvent((a,b)) =>\ndiff --git a/notes.txt b/notes.txt\nindex bdb26a7..f5013cd 100644\n--- a/notes.txt\n+++ b/notes.txt\n@@ -1,3 +1,6 @@\n+\n+TODO(cs): double check that replay run actually retriggers violation...\n+\n == Minimizing internals ==\n \n DPOR that just tries to remove (not add or reorder) internal events. Might be\n@@ -10,6 +13,10 @@ DDMin that splits along DAG (DepGraph) lines...\n IDEA: try first pruning external events that have long happens-before\n chains leading up to bug.\n \n+== Edit Distance ==\n+\n+Online version using a prefix trie\n+\n == Hacks ==\n \n Possibly find a hackier version of CheckpointRequests that doesn't require us\n@@ -35,6 +42,7 @@ about it going off infinitely, etc.)\n TODO(cs): understand why my optimization of pruning out Sends to non-existent\n actors wasn't correct\n TODO(cs): timers break eventTrace.filterSends\n+TODO(cs): CheckpointRequests/Reply should really be handled by Instrumenter()\n -----------------\n TODO(cs): do we handle context.system.eventStream.publish properly? It's\n           apparently only a local facility, not a cluster facility.\ndiff --git a/src/main/scala/pl/project13/RaftChecks.scala b/src/main/scala/pl/project13/RaftChecks.scala\nindex 24de040..a563284 100644\n--- a/src/main/scala/pl/project13/RaftChecks.scala\n+++ b/src/main/scala/pl/project13/RaftChecks.scala\n@@ -72,6 +72,8 @@ case class RaftViolation(fingerprint2affectedNodes: Map[String, Set[String]])\n   def matches(other: ViolationFingerprint) : Boolean = {\n     other match {\n       case RaftViolation(otherMap) =>\n+        println(\"matches: \"  + fingerprint2affectedNodes.keys)\n+        println(\"other: \" + otherMap.keys)\n         // Slack matching algorithm for now: if any fingerprint matches, the whole\n         // thing matches\n         return !fingerprint2affectedNodes.keys.toSet.intersect(otherMap.keys.toSet).isEmpty\n@@ -239,7 +241,8 @@ class ElectionSafetyChecker(parent: RaftChecks) {\n     state match {\n       case LeaderMeta(_, term, _) =>\n         if ((term2leader contains term) && term2leader(term) != actor) {\n-          val fingerprint = \"ElectionSafety:\" + actor + \":\" + term2leader(term) + \":\" + term\n+          val sorted = List(actor, term2leader(term)).sorted.mkString(\":\")\n+          val fingerprint = \"ElectionSafety:\" + sorted + \":\" + term\n           val affected = Set(actor, term2leader(term))\n           return Some(new HashMap ++ Seq(fingerprint -> affected))\n         }\n@@ -257,6 +260,7 @@ class LogMatchChecker(parent: RaftChecks) {\n \n   def checkActor(actor: String) : Option[Map[String, Set[String]]] = {\n     return None\n+    // TODO(cs): sort actors in fingerprint string\n     // TODO(cs): return affected nodes\n     /*\n     val otherActorLogs = parent.actor2log.filter { case (a,_) => a != actor }\n@@ -307,6 +311,7 @@ class LeaderCompletenessChecker(parent: RaftChecks) {\n \n   def check() : Option[Map[String, Set[String]]] = {\n     return None\n+    // TODO(cs): sort actors in fingerprint string\n     // TODO(cs): return affected nodes\n     /*\n     val sortedTerms = parent.term2leader.keys.toArray.sortWith((a,b) => a < b)\n@@ -349,6 +354,7 @@ class StateMachineChecker(parent: RaftChecks) {\n   // infer that they should commit an given entry)\n   def check() : Option[Map[String, Set[String]]] = {\n     return None\n+    // TODO(cs): sort actors in fingerprint string\n     // TODO(cs): return affected nodes\n     /*\n     val allCommittedIndices = parent.allCommitted.toArray.map(c => c._3)\ndiff --git a/src/main/scala/pl/project13/Runner.scala b/src/main/scala/pl/project13/Runner.scala\nindex bdb3ae0..23677f5 100644\n--- a/src/main/scala/pl/project13/Runner.scala\n+++ b/src/main/scala/pl/project13/Runner.scala\n@@ -144,7 +144,7 @@ object Main extends App {\n     val tuple = RunnerUtils.fuzz(fuzzer, raftChecks.invariant,\n                                  fingerprintFactory,\n                                  validate_replay=Some(replayerCtor),\n-                                 maxMessages=Some(6000)) // 170\n+                                 maxMessages=Some(170))\n     traceFound = tuple._1\n     violationFound = tuple._2\n     depGraph = tuple._3\n@@ -160,7 +160,7 @@ object Main extends App {\n     traceFound.filterCheckpointMessages(), violationFound,\n     depGraph=Some(depGraph), initialTrace=Some(initialTrace),\n     filteredTrace=Some(filteredTrace)) else\n-    \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz_2015_04_02_19_54_17_IncDDMin_DPOR/\"\n+    \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz_2015_04_03_15_59_16_IncDDMin_DPOR\"\n \n   /*\n   println(\"Trying randomDDMin\")\n@@ -219,7 +219,46 @@ object Main extends App {\n         event_mapper=Some(Init.eventMapper))\n \n     serializer.serializeMCS(dir, mcs5, stats5, mcs_execution5, violation5)\n+\n+    mcs_execution5 match {\n+      case Some(trace) =>\n+        // XXX\n+        val deserializer = new ExperimentDeserializer(dir)\n+\n+        var (stats, lastFailingTrace) =\n+          RunnerUtils.minimizeInternals(fingerprintFactory,\n+                                        mcs5,\n+                                        trace,\n+                                        deserializer.get_actors,\n+                                        raftChecks.invariant,\n+                                        violation5,\n+                                        event_mapper=Some(Init.eventMapper))\n+      case None =>\n+        None\n+    }\n   }\n \n-  // TODO(cs): minimize internals.\n+  if (!fuzz) {\n+    val mcs_dir = \"/Users/cs/Research/UCB/code/sts2-applications/experiments/akka-raft-fuzz_2015_04_19_14_04_14_IncDDMin_DPOR\"\n+    var msgDeserializer = new RaftMessageDeserializer(Instrumenter().actorSystem)\n+\n+    println(\"Trying replay..\")\n+    RunnerUtils.replayExperiment(mcs_dir, fingerprintFactory, msgDeserializer,\n+                                 Some(raftChecks.invariant))\n+\n+    msgDeserializer = new RaftMessageDeserializer(Instrumenter().actorSystem)\n+    val dummySched = new ReplayScheduler()\n+    val (mcs, trace, violation, actors) = RunnerUtils.deserializeMCS(mcs_dir,\n+                                                                     msgDeserializer,\n+                                                                     dummySched)\n+    dummySched.shutdown\n+    var (stats, lastFailingTrace) =\n+      RunnerUtils.minimizeInternals(fingerprintFactory,\n+                                    mcs,\n+                                    trace,\n+                                    actors,\n+                                    raftChecks.invariant,\n+                                    violation,\n+                                    event_mapper=Some(Init.eventMapper))\n+  }\n }",
      "status": "On branch akka-raft\nYour branch is ahead of 'origin/akka-raft' by 3 commits.\n  (use \"git push\" to publish your local commits)\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n\tmodified:   interposition/src/main/scala/verification/RunnerUtils.scala\n\tmodified:   interposition/src/main/scala/verification/schedulers/STSScheduler.scala\n\tmodified:   notes.txt\n\tmodified:   src/main/scala/pl/project13/RaftChecks.scala\n\tmodified:   src/main/scala/pl/project13/Runner.scala\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\n\treorderings.py\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")"
    }
  },
  "sys": {
    "lsb_release": "",
    "uname": "Darwin yossarian 14.1.0 Darwin Kernel Version 14.1.0: Thu Feb 26 19:26:47 PST 2015; root:xnu-2782.10.73~1/RELEASE_X86_64 x86_64"
  },
  "timestamp": "2015_04_19_15_37_18",
  "user": "cs"
}
